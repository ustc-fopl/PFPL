\section{6.2进展性}

进展性理论持有的观点是良类型程序不会 “中止”。

证明的关键是以下引理，它们描述了每种类型的值。

引理 6.3 (规范形式). {\it 如果} $e\iota/\mathrm{a}/且 e$ : $\tau$, {\it 那么}e val%e val，下同

{\it 1. 如果} $\tau=\mathrm{n}\mathrm{u}\mathrm{m}$, {\it 那么对某个数字} $n.$， $e=\mathrm{n}\mathrm{u}\mathrm{m}[n]$ 

2. {\it 如果} $\tau=\mathrm{s}\mathrm{t}\mathrm{r}$, {\it 那么对某个字符串} $\mathrm{s}.$，$e=$ str $[\mathrm{s}]$ 

{\it 证明}. 在规则（4.1）和（5.3）上归纳。 . $\square $

进展性通过归纳规则（4.1）定义语言的静态得证。

定理 6.4 (进展性. {\it 如果} $ e:\tau$, {\it 那么或者} $e\iota/\mathrm{a}/$, {\it 或者存在} $e'$ {\it 使} $e\mapsto e'.$

{\it 证明}. 证明通过类型推导归纳进行，只考虑一种情况，对于规则（4.1d），

$$
\frac{e_{1}:\mathrm{n}\mathrm{u}\mathrm{m}e_{2}:\mathrm{n}\mathrm{u}\mathrm{m}}{\mathrm{p}1\mathrm{u}\mathrm{s}(e_{1};e_{2}):\mathrm{n}\mathrm{u}\mathrm{m}}\ '
$$

上下文为空，因为我们不考虑闭项

归纳可得 $e_{1}$ 是值, 或存在 e1 使 $e_{1} \mapsto$e1. 在后一种情况下，根据要求，它遵循 plus $(e_{1};\cdot e_{2}) \mapsto$plus (e1; $e_{2}$), 在前一种情况下，同样归纳得到 $e_{2}$ 是值, 或存在 $e_{2}'$ 使 $e_{2} \mapsto e_{2}'$. 后一情况，有 plus $(e_{1};\cdot e_{2}) \mapsto$
%e1有问题，e1;e2应为e_{1};e_{2}，分号位置有误
plus $(e_{1;}\cdot e_{2}')$ 。 对于前一情况，通过
引理6.3，有 $e_{1}=\mathrm{n}\mathrm{u}\mathrm{m}[n_{1}]$

和 $e_{2}=$ num[{\it n}2], 因此

plus(num $[n_{1}]_{;}$. num[{\it n}2]) $\mapsto \mathrm{n}\mathrm{u}\mathrm{m}[n_{1}+n_{2}].$
$$
\square 
$$

因为表达式的类型规则是语法制导的，所以进展性定理可以同样由对 $e$ 的结构归纳来证

明，每一步都要使用反演定理。但这种方法在非语法制导的类型规则下不适用，也就是说，

一个给定的表达式形式有多个规则。这样的规则表达起来并不困难，只要在类型规则上而不是在表达式结构上进行归纳证明。
%这样的规则表达起来并不困难，只要在类型规则上而不是在表达式结构上进行归纳证明。

总之，保留性与进展性的结合构成安全的证明。进展定理确保了良类型的表达式不会在弱

定义的状态下“卡住”，而保留定理则确保了步骤执行后，结果仍是良类型的（类型保持相
0
同）。因此，这两个部分共同工作，以确保静态和动态是一致的，并且在评估良类型的表达

式时不会遇到弱定义的状态。
