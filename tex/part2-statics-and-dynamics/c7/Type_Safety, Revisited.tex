\section{7.3 类型安全，重查}

第6 章给出了类型安全的定义（定理6.1），即保留性与进展性。当将这些概念应用到转换系
统给出的分析动态时，这些概念是有意义的，也正是贯穿全书的做法。但是如果我们在动态
下分析呢?这种情况下如何保证类型安全？

回答是不能。虽然有分析动态的保存属性的类比，但是没有明确的进展属性的类比。保留
性可以这么说，如果 $e \Downarrow v$ 且 $e$ : $\tau$, 那么 $v$ : $\tau$. 通过对分析规则的归纳，可以很容易地证明这一点。但是进展性的类比是什么呢？我们可能会说，如果 $e$ : $\tau$, 那么对于某个 $v$， $e\Downarrow v$ 。虽然这个性质对 $\mathrm{E}$成立，它要求的不仅仅是进展性--它要求每个表达式都有一个值!

如果扩展 $\mathrm{E}$ 以承认可能导致错误的操作(如第6.3 节中所讨论的)，或承认不终止的表达式，则此属性无效，即使进展仍然有效。

对于这种情况，一种可能的看法是得出这样的结论:类型安全不能在分析动态的上下文中
得到适当的讨论，而只能通过结构动态来讨论。另一种观点是通过对动态类型错误的显式检
查来检测动态，并且要显示任何带有动态弱类型的表达式都必须是静态弱类型的。在反例中
重新声明，这意味着静态良类型的程序不能导致动态类型错误。这种观点的一个困难是，我
们必须明确地解释一种错误的形式，以证明它不可能出现!然而，可以利用分析动态建立一
种表面的类型安全。

我们定义一个判断 $e$ ?? 表示表达式 $e$在执行时 {\it 出错} 。 ''出错''%断言e，双引号应为中文 
的精确定义通过一组规则给出，但应该涵盖所有类型错误的情况。以下规则代表一般情况：%但应该涵盖所有类型错误的情况
\begin{center}
$\overline{\mathrm{p}1\mathrm{u}\mathrm{s}(\mathrm{s}\mathrm{t}\mathrm{r}[\mathrm{s}]_{;}\cdot e_{2})??}$   (7.3a)

$\displaystyle \frac{e_{1}\mathrm{v}\mathrm{a}1}{\mathrm{p}\mathrm{l}\mathrm{u}\mathrm{s}(e_{1};\mathrm{s}\mathrm{t}\mathrm{r}[\mathrm{s}])??}$   (7.3b)
\end{center}
这些规则明确检测字符串加法中的错误应用；类似的规则控制着语言的每一个原始结
构。%字符串加法

定理 7.5. {\it 如果} $e$ ??, {\it 那么不存在} $\tau$ {\it 满足} $e$ : $\tau.$

{\it 证明}. 通过规则（7.3）的归纳规则得到。例如，规则（7.3a），我们记有 str $[\mathrm{s}]$ : $\mathrm{s}\mathrm{t}\mathrm{r}$,因此 plus(str $[\mathrm{s}]_{;}\cdot e_{2}$) 是弱类型的。  $\square $

推论 7.6. {\it 如果} $e$ : $\tau$, {\it 那么} $\neg (e\ ??)$ .

除了不得不定义判断 $e$ ?? 的不便之外，仅为了表明它对于良类型程序是不可避免的，这
在方法论上有明显的缺陷。如果我们省略了定义判断 $e$ ??的一个或多个规则，定理7.5 的证
明仍然有效；无法确保包含足够多运行时的类型错误检查。我们可以证明我们定义的那些
不能在一个良类型程序中出现，但是我们不能证明我们已经涵盖了所有可能的情况。相比
之下，结构动态不考虑任何弱类型表达式的行为。 因此，任何弱类型表达式都将在没有我
们明确干预的情况下“卡住”，而进展定理排除了所有这种情况。此外，转换系统更接近于
实现--编译器不需要为检测运行时类型错误做任何规定。相反，它依赖静态来确保这些
不会出现，并且不为任何弱类型的程序赋予任何意义。因此，执行效率更高，语言定义也
更简单。
