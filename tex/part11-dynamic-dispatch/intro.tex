通常，一个类型的各个值会被划分若干\textit{类} （\textit{class}）中，每一类的数据分别具有不同的内在结构。以平面上的坐标点为例，可以分为笛卡尔坐标系形式的类与极坐标系形式的类，它们都由一对实数表示。在笛卡尔坐标系中，这两的数字对应着点的 $ x $ 与 $ y $ 的坐标；但在极坐标系中，它们对应着点的级径 $ r $ 以及与极角 $ \theta $。每个被分类的值叫做该类的一个 \textit{对象}（\textit{object}）或 \textit{实例} （\textit{instance}）。类决定了被分类的数据的类型，即该类的\textit{实例类型}（\textit{instance type}）；该数据本身称之为对象的\textit{实例数据}（\textit{instance data}）。

\textit{方法}（\textit{method}）是作用在被分类数据上的函数。方法的行为由它参数的类决定\footnote[1]{简单起见，我们假定可以同时分派多个参数的类。我们只关注单一的分派。}。方法的\textit{分派}（\textit{dispatch}）由参数的类别决定。由于这种选择是运行时发生的，因此我们称其为\textit{动态分派}（\textit{dynamic dispatch}）。比如，用来计算点到原点距离平方的方法在两种坐标系下表现不同。在笛卡尔坐标系中，距离的平方为 $x^2 + y^2$，而在极坐标系中为 $r^2$；再比如，判断点的所在象限时，笛卡尔坐标系的点需要考察 $ x $ 与 $ y $ 的符号，而在极坐标系中需要考察 $ \theta $ 除以 $ \pi / 2 $。

动态分派经常用一类特定的实现策略描述，我们称之为\textit{基于类的}（\textit{class-based}）组织。在这种组织中，每个对象被描述为作用在该对象的上的一列方法。有时我们也用一种与其等价的组织，\textit{基于方法的}（\textit{method-based}）组织，其中方法的行为随着作用对象的类型不同而不同。不管是哪一种组织，核心想法都是：（1）对象总是属于某一类，（2）方法在类上进行分派。基于类的与基于方法的组织之间是可以相互转化的，实际上，它们是加类型和积类型的天然对偶关系。通过观察每个对象上的每个方法的行为，我们可以解释这种对称性，并称其为\textit{分派矩阵}（\textit{dispatch matrix}）。由分派矩阵，我们会发现这两种组织的对称关系是显然的。
