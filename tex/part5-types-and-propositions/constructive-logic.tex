\chapter{构造逻辑}

构造逻辑在实践中修正了数学推理的原则。在数学中，一个命题仅当它有证明的时被断言为真，并且仅当它有反例时被断言为假。
因为一直存在着未能解决的问题，所以我们不能总是期望得到一个命题的真假，因为在大多数情况下，我们既不能对一个命题证明也不能对它反驳。构造逻辑可以被描述为\textit{类似人思考}的逻辑，但它与古典逻辑又存在不同，它又可以被描述为\textit{上帝脑海}的逻辑。

从构造性的观点来看，当一个命题有证明时，这个命题为真。 而所谓的证明其实是一种社会建构，是人们之间就什么是有效论证达成的共识。
逻辑规则编码了一套可用于有效证明的推理原则。 有效的证明形式由被断言为真的命题的最外层结构所决定。
例如，一个合取的证明由每个证明的合取式组成，而一个蕴涵的证明将其前件的证明转化为其后件的证明。 总的来看，证明的形式与编程语言的表达形式完全一致。
每个命题都与其证明的类型相关联；那么证明就是一个与类型相关联的表达式。 程序与证明之间的这种联系导致了证明的动态性。
在这种情况下，构造逻辑中的证明具有\textit{计算性内涵}，也就是说它们可以被解释为相关类型的可执行程序。
与此对应的，程序则具有\textit{数学性内涵}并可以作为与其类型相关的命题的证明。


逻辑和编程的统一被称为\textit{命题作为类型}原则。 它是编程语言理论的中心组织原则。 命题与类型一致，证明与程序一致。 编程技术对应于证明方法;  证明技术对应于编程方法。将类型视为程序的行为规范，将命题视为其证明是实现前述规范的解的问题陈述。
\section{构造语义}
构造逻辑关注两个断言，$\phi\,\mathsf{prop}$ 和 $\phi\,\mathsf{true}$，前者表示${\phi}$表示一个命题，后者表示${\phi}$是一个真命题。构造性和非构造性逻辑的区别在于，构造逻辑中的一个命题不仅仅被认为是一个真值，而且是作为一个由证明提供解（如果存在）的\textit{问题陈述语句}。根据普通的数学实践，一个命题如果为\textit{真}，仅当它有一个证明。在实践中没有除存在证明之外的论证标准。


通过证明来确定真具有重要而且可能令人惊讶的结论。其中最重要的结论是，我们不能鲁莽的确定一个命题是真的还是假的。如果一个命题是真的意味着我们要证明它，那么这个命题是假的意味着什么？这意味着我们要找到它的\textit{反例}，表明它不能被证明。也就是说，如果我们能够表明与已知事实相矛盾的假设为真（有证明），则该命题是假的。从这个意义上讲，构造逻辑是一种\textit{积极的}或\textit{有效的信息逻辑}——我们必须以证明的形式提供明确的论证来证明命题的真假。


鉴于显然不是每个命题都可判断真假。因为如果${\phi}$表示一个未解决的命题，比如着名的$\mathsf{P}\stackrel{?}{=}\mathsf{NP}$问题，那么我们既不能证明也不能反驳（仅仅缺少证明不是对它的反驳）。因为它尚未解决，这种问题是\textit{不可判定的}。因为总会有一些未解决的问题（有无穷多的命题，但在某个特定时刻只有有限多个证明），所以我们不能说每个命题都是\textit{可判定的}，也就是说，是真的还是假的。


当然，有些命题是可判定或者为真或者为假的。例如，如果${\phi}$表示自然数之间的不等式，则${\phi}$是可判定的，因为我们总是可以计算出对于给定的自然数
$m$ 和 $n$，无论 $m \leq n$ 还是 $m \not\leq n$ --- 我们都可以证明或反驳给定的不等式。
这个论点并没有扩展到实数。要了解为什么不这样做，请考虑用十进制数展开实数的表示。
在任何有限的时间我们将只考虑扩展的一个有限的初始段，这不足以确定它是否小于$1$ 。因为如果我们已经计算了扩展为
$0.99...9$，我们不能在任何时候确定是否缺少数字 $1$。


构造性的态度只是简单的接受这种不可避免的局面，并且让我们保持淡定。面对问题时，我们别无选择，只能卷起袖子，试图证明或反驳。而且往往不能保证一定成功！生活是艰难的，但我们总是稀里糊涂的就度过去了。
\section{构造逻辑}
构造逻辑的断言 $\phi\,\mathsf{prop}$ 和 $\phi\,\mathsf{true}$ 本身很少有意义，而在假言断言的形式的上下文中

$$\phi_1\;\mathsf{true}, \ldots, \phi_n \; \mathsf{true} \vdash \phi \; \mathsf{true}.$$


这个断言表明在每个假设$\phi_1, \ldots, \phi_n$也是为真的情况下（有证明）,命题 $\phi$ 是真的（有证明）。 当然，当$n = 0$时，这个断言即为 $\phi \; \mathsf{true}$。

在专门用于构造逻辑时，通过以下假言断言的结构特性来定义我们的表达：
\begin{subequations}
    \begin{gather}
       \dfrac{}
             {\Gamma,\phi\; \mathsf{true} \vdash \phi\; \mathsf{true}} \\
       \dfrac{\Gamma \vdash \phi_1\; \mathsf{true}\quad\Gamma,\phi_1\; \mathsf{true} \vdash \phi_2\; \mathsf{true}}
             {\Gamma \vdash \phi_2\; \mathsf{true}} \\
       \dfrac{\Gamma \vdash \phi_2\; \mathsf{true}}
             {\Gamma,\phi_1\; \mathsf{true} \vdash \phi_2\; \mathsf{true}} \\
       \dfrac{\Gamma,\phi_1\; \mathsf{true},\phi_1\; \mathsf{true} \vdash \phi_2\; \mathsf{true}}
             {\Gamma,\phi_1\; \mathsf{true} \vdash \phi_2\;  \mathsf{true}} \\
       \dfrac{\Gamma_1,\phi_2\; \mathsf{true},\phi_1\; \mathsf{true},\Gamma_2 \vdash \phi\; \mathsf{true}}
              {\Gamma_1,\phi_1\; \mathsf{true},\phi_2\; \mathsf{true},\Gamma_2 \vdash \phi\; \mathsf{true}}
    \end{gather}
\end{subequations}

最后两条规则是隐含的，因为我们认为${\Gamma}$是一组假设，所以两个“副本”区域一样好且假言的顺序也没有关系。

\subsection{可证性}
命题逻辑的语法由以下推导给出：

$$
\begin{array}{llll}
\mathsf{Prop}\quad\phi\quad ::= \quad &\top              &\top                   &\text{永真}\\
                                    &\bot                  &\bot                   &\text{永假}\\\
                                    &\land(\phi_1;\phi_2)  &\phi_1 \land \phi_2\;  &\text{合取}\\
                                    &\lor(\phi_1;\phi_2)   &\phi_1 \lor \phi_2\;   &\text{析取}\\
                                    &\supset(\phi_1;\phi_2) &\phi_1 \supset \phi_2 & \text{蕴含}
\end{array}
$$


命题逻辑的联结词由一些规则赋予意义，这些规则定义了（a）什么构成了从给定联结词形成的命题的``直接''证明，
以及（b）如何在其他命题的``间接''证明中利用这种证明的存在性。 这些被称为联结词的\textit{引入}和\textit{消去}规则。
\textit{证明守恒}的原则指出， 这些规则是可逆的——消去规则不能提取比引入规则引入的信息更多的信息（以证明的形式），
并且引入规则可以从消去规则提取的信息中重构证明。

\textbf{永真}\qquad 我们的第一个命题是纯粹的真。没有额外的信息来用于证明，因此它之中没有信息能被包含。
\begin{subequations}
    \begin{gather}
    \dfrac{}{\Gamma \vdash \top \;\mathsf{true}}\\
    \text{（没有消去形式）}
    \end{gather}
\end{subequations}


\textbf{合取}${\qquad}$合取表示它的两个合取子式同时为真。
\begin{subequations}
    \begin{gather}
        \dfrac{\Gamma \vdash \phi_1\; \mathsf{true}\quad\Gamma \vdash \phi_2\; \mathsf{true}}{\Gamma \vdash \phi_1 \land \phi_2\; \mathsf{true}}\\
        \dfrac{\Gamma \vdash \phi_1 \land \phi_2\; \mathsf{true}}{\Gamma \vdash \phi_1\; \mathsf{true}}\\
        \dfrac{\Gamma \vdash \phi_1 \land \phi_2\; \mathsf{true}}{\Gamma \vdash \phi_2\; \mathsf{true}}
    \end{gather}
\end{subequations}

\textbf{蕴含}${\qquad}$表达了一个命题在一个假设下的真。
\begin{subequations}
    \begin{gather}
    \dfrac{\Gamma,\phi_1\; \mathsf{true} \vdash \phi_2\; \mathsf{true}}{\Gamma \vdash \phi_1 \supset \phi_2\; \mathsf{true}}\\
    \dfrac{\Gamma \vdash\; \phi_1 \supset \phi_2\; \mathsf{true}\quad\Gamma \vdash \phi_1\; \mathsf{true}}{\Gamma \vdash \phi_2\; \mathsf{true}}
    \end{gather}
\end{subequations}


\textbf{永假}${\qquad}$永假表示纯粹的假（可反驳）命题。
\begin{subequations}
    \begin{gather}
    （没有引入形式）\\
    \frac{\Gamma \vdash \bot\; \mathsf{true}}{\Gamma \vdash \phi\; \mathsf{true}}
    \end{gather}
\end{subequations}

\textbf{析取}${\qquad}$析取表示两个子命题同时或任意为真。
\begin{subequations}
    \begin{gather}
       \dfrac{\Gamma \vdash \phi_1\; \mathsf{true}}
              {\Gamma \vdash \phi_1 \lor \phi_2\; \mathsf{true}}\\
       \dfrac{\Gamma \vdash \phi_2\; \mathsf{true}}
              {\Gamma \vdash \phi_1 \lor \phi_2\; \mathsf{true}}\\
       \dfrac{\Gamma \vdash \phi_1 \lor \phi_2\; \mathsf{true}\quad\Gamma,\phi_1\; \mathsf{true} \vdash \phi\; \mathsf{true}\quad\Gamma,\phi_2 \; \mathsf{true}\vdash \phi\; \mathsf{true}}
              {\Gamma \vdash \phi\; \mathsf{true}}
    \end{gather}
\end{subequations}

\textbf{否定}${\qquad}$命题${\phi}$的否定${\lnot\phi}$定义为蕴涵${\phi\supset\bot}$。 因此，如果${\phi}$ true ${\vdash\bot}$ true，那么${\lnot\phi}$是真的，也就是说${\phi}$的真是可以反驳的，因为我们可以从任何所谓的${\phi}$的证明中推导出证明的永假。因为构造性的真被定义为是存在证明，否定的隐含语义是相当强的。特别是，一个问题${\phi}$当我们既不能肯定也不能反驳时，它就成为了开放命题。相比之下，古典的真理概念为每个命题分配一个固定的真值，因此每个命题要不为真要不为假。
\subsection{证明项}
命题作为类型这个原则的关键在于显示化证明的形式。表明了${\phi}$有证明的基础断言${\phi}$ true，被断言\textit{p} : ${\phi}$所取代，表明\textit{p}是${\phi}$的证明。 （有时候\textit{p}被称为“证明项”，但我们会简单地称p为“证明”。）假言断言相应地进行了修改，变量代表了假定但未知的证明：
$$x_1 : \phi_1,...,x_n : \phi_n\vdash p : \phi.$$


我们再次让${\Gamma}$规定没有重复变量的假设列表。

证明项的语法由以下语法给出：

$$
\begin{array}{llll}
\mathsf{Prf}\quad p \quad::=\quad
    &\mathtt{true}\text{-}\mathsf{l}            &  \langle \rangle           &\text{永真引入规则}\\
    &\mathtt{and}\text{-}\mathsf{l} (p_1; p_2) & \langle p_1, p_2  \rangle   &\text{合取引入规则}\\
    &\mathtt{and}\text{-}\mathsf{E}[\mathtt{l}] (p)  & p \cdot \mathtt{l}    &\text{合取消去规则}\\
    &\mathtt{and}\text{-}\mathsf{E}[\mathtt{r}] (p)  & p \cdot \mathtt{r}    &\text{合取消去规则}\\
    &\mathtt{imp}\text{-}\mathsf{l}(x. p)            & \lambda (x)  p        &\text{蕴含引入规则}\\
    &\mathtt{imp}\text{-}\mathsf{E}(p_1;p_2)        & p_1 (p_2)              &\text{蕴含消去规则}\\
    &\mathtt{false}\text{-}\mathsf{E}(p)            & \mathtt{abort}(p)       &\text{永假消去规则}\\
    &\mathtt{or}\text{-}\mathsf{l}[\mathtt{l}] (p)  & \mathtt{l} \cdot p   &\text{析取引入规则}\\
    &\mathtt{or}\text{-}\mathsf{l}[\mathtt{r}] (p)  & \mathtt{r} \cdot p   &\text{析取引入规则}\\
    &\mathtt{or}\text{-}\mathsf{E}(p;x_1 . p_1; x_2. P_2)
                &\mathtt{case}\; p \; \{\mathtt{l} \cdot x_1 \hookrightarrow p_1 | \mathtt{r} \cdot x_2\hookrightarrow p_2 \}
                & \text{析取消去规则}
\end{array}
$$

证明项的具体语法被选择来加强第12.4节中讨论的命题和类型之间的对应关系。

构造命题逻辑的规则可以使用证明项重写如下：

\begin{subequations}
    \begin{gather}
       \dfrac{}{\Gamma \vdash \left \langle\right \rangle : \top} \\
       \dfrac{\Gamma \vdash p_1 : \phi_1\quad\Gamma \vdash p_2:\phi_2}{\Gamma \vdash \left \langle p_1,p_2 \right \rangle : \phi_1 \land \phi_2} \\
       \dfrac{\Gamma \vdash p_1 : \phi_1 \land \phi_2}{ \Gamma \vdash p_1 \cdot \mathtt{l} : \phi_1} \\
       \dfrac{\Gamma \vdash p_1 : \phi_1 \land \phi_2}{ \Gamma \vdash p_1 \cdot \mathtt{r} : \phi_2} \\
       \dfrac{\Gamma,x : \phi_1 \vdash p_2 : \phi_2}{ \Gamma \vdash \lambda\left(x\right)p_2 : \phi_1 \supset \phi_2} \\
       \dfrac{ \Gamma \vdash p : \phi_1 \supset \phi_2\quad\Gamma \vdash p_1 : \phi_1}{\Gamma \vdash p(p_1) : \phi_2} \\
       \dfrac{\Gamma \vdash p : \bot}{\Gamma \vdash \mathtt{abort}\left(p\right) : \phi} \\
       \dfrac{\Gamma \vdash p_1 : \phi_1}{ \Gamma \vdash \mathtt{l} \cdot p_1 : \phi_1 \lor \phi_2} \\
       \dfrac{\Gamma \vdash p_2 : \phi_2}{ \Gamma \vdash \mathtt{r} \cdot p_2 : \phi_1 \lor \phi_2} \\
       \dfrac{\Gamma \vdash p : \phi_1 \lor \phi_2\quad\Gamma,x_1 : \phi_1 \vdash p_1 : \phi\quad\Gamma,x_2 : \phi_2 \vdash p_2 : \phi}
             { \Gamma \vdash \mathtt{case}\; p\; \left\{\mathtt{l} \cdot x_1\hookrightarrow p_1 |\mathtt{r} \cdot x_2\hookrightarrow p_2\right\} : \phi}
    \end{gather}
\end{subequations}


\section{证明动态性}
\textit{根岑原则}给出了构造逻辑中的证明项。它指出消去形式与引入形式可逆。根岑原则的一个方面是\textit{证明守恒}原则，该原则规定引入到命题证明中的信息可以在不被消去损失的情况下提取。例如，我们可以说根据下列定义式合取消去规则与合取引入规则是可逆的：
\begin{subequations}
    \begin{gather}
       \dfrac{\Gamma \vdash p_1 : \phi_1\quad\Gamma \vdash p_2:\phi_2}
             {\Gamma \vdash \left \langle p_1,p_2  \right \rangle \cdot \mathtt{l} \equiv p_1: \phi_1} \\
       \dfrac{\Gamma \vdash p_1 : \phi_1\quad\Gamma \vdash p_2:\phi_2}
             {\Gamma \vdash \left \langle p_1,p_2  \right \rangle \cdot \mathtt{r} \equiv p_2 : \phi_2}
    \end{gather}
\end{subequations}

根岑原则的另一个方面是\textit{证明可逆性}原则，即证明可以从可以通过消去从中提取的信息重构。在合取的情况下，这可以由定义式表示：
\begin{equation}
       \dfrac{\Gamma \vdash p_1 : \phi_1 \quad\Gamma \vdash p_2:\phi_2}
             {\Gamma \vdash \left \langle p \cdot \mathtt{l},p \cdot \mathtt{r} \right \rangle \equiv p : \phi_1 \land \phi_2 }
\end{equation}

对于其他联结词，有类似的等价。例如，这些规则给出了蕴含的守恒和可逆性原则：
\begin{subequations}
    \begin{gather}
       \dfrac{\Gamma,x : \phi_1 \vdash p_2 : \phi_2\quad\Gamma \vdash p_2 : \phi_2}
             {\Gamma \vdash \left(\lambda\left(x\right)p_2\right)\left(p_1\right) \equiv\left[p_1/x\right] p_2: \phi_2} \\
       \dfrac{\Gamma \vdash p : \phi_1 \supset \phi_2 }
             {\Gamma \vdash \lambda\left(x\right)\left(p\left(x\right)\right) \equiv p : \phi_1 \supset \phi_2}
    \end{gather}
\end{subequations}

相应的析取和永假规则如下：
\begin{subequations}
    \begin{gather}
       \dfrac{\Gamma \vdash p : \phi_1 \lor \phi_2\quad\Gamma,x_1 : \phi_1 \vdash p_1 : \psi\quad\Gamma,x_2 : \phi_2 \vdash p_2 : \psi}
             { \Gamma \vdash \mathtt{case}\; \mathtt{l}\; \cdot p\left\{\mathtt{l} \cdot x_1\hookrightarrow p_1 | \mathtt{r} \cdot x_2\hookrightarrow p_2\right\} \equiv \left[p/x_1\right]p_1 : \psi}\\
       \dfrac{\Gamma \vdash p : \phi_1 \lor \phi_2\quad\Gamma,x_1 : \phi_1 \vdash p_1 : \psi\quad\Gamma,x_2 : \phi_2 \vdash p_2 : \psi}
             { \Gamma \vdash \mathtt{case}\; \mathtt{r}\; \cdot p\left\{\mathtt{l} \cdot x_1\hookrightarrow p_1 | \mathtt{r} \cdot x_2\hookrightarrow p_2\right\} \equiv \left[p/x_2\right] p_2  : \psi}\\
       \dfrac{\Gamma \vdash p : \phi_1 \lor \phi_2\quad\Gamma,x : \phi_1 \lor \phi_2 \vdash q : \psi}
             { \Gamma \vdash   \left[p/x\right]q \equiv \mathsf{case}\; p\; \left\{ \mathtt{l} \cdot x_1\hookrightarrow \left[\mathtt{l} \cdot x_1/x\right] q| \mathtt{r} \cdot x_2\hookrightarrow \left[\mathtt{r} \cdot x_2/x\right] q\right\}: \psi}\\
       \dfrac{\Gamma \vdash p : \bot\quad\Gamma,x : \bot \vdash q : \psi}
             {\Gamma \vdash \left[p/x\right]q \equiv \mathtt{abort}\left(p\right) : \psi}
    \end{gather}
\end{subequations}

\section{命题作为类型}

回顾构造逻辑中的证明的动态和静态性，揭示了各种类型表达式的动态和静态性的惊人相似之处。
例如，合取的引入规则指定了一个合取的证明由一对证明组成，每个子式对应一个证明，并且消去规则颠倒了这一点，从而允许我们从任何合取证明中提取每个子式的证明。
这与积类型的静态语义有明显的类似，积类型的引入形式也是一对，消去形式是投影。
根岑原理也将类比扩展到动态语义，因此合取的消去形式等同于从有序对提取适当分量的投影。

以下图表总结了命题与类型之间以及证明与程序之间的对应关系：

$$
\begin{array}{ll}
\text{命题}           & \text{类型}            \\
\top                  & \mathtt{unit}          \\
\bot                  & \mathtt{void}          \\
\phi_1 \land \phi_2   & \tau_1 \times \tau_1   \\
\phi_1 \supset \phi_2 & \tau_1 \to \tau_1      \\
\phi_1 \lor \phi_2    & \tau_1 + \tau_1
\end{array}
$$

命题和类型之间的对应关系是编程语言理论的基石。它揭示了计算和演绎之间的深层联系，并且通过将语言结构和推理原理相互联系起来作为分析的框架。
\section{总结}
命题类型的原则起源于布劳威尔开发的直觉主义逻辑的语义。据此语义，命题的真由一个为其提供可计算证据的构造所证。证据的形式由命题的形式决定，这也暗示的证据是一个可计算的并可以将假设的证据转化为结论的证据的函数。海廷介绍了这种语义的明确表述，并由包括德布鲁恩，柯瑞，根岑，吉拉德，霍华德，科尔莫戈罗夫，马丁洛夫和泰特等人进一步的发展深化。命题类型对应有时称为\textit{柯瑞——霍华德同构}，但是这个术语忽略了刚才提到的其他人的重要贡献。而且，这种对应通常不是一种同构;而是表达了布劳威尔的说法，即证明的概念最好由更一般的构造（程序）概念来解释。

\section*{练习}
\textbf{12.1}.\textit{排中律}（LEM）的描述如下，即每个命题${\phi}$在${\phi \land \lnot\phi}$为真的意义上是\textit{可判定的}。构造性的排中律为，对于每个命题${\phi}$，我们要么有${\phi}$的证明，要么有${\phi}$的驳斥的证明（${\lnot\phi}$的证明）。因为这显然不是一般情况，人们可能会怀疑排中律并不具有构造的有效性。正是如此，但不是在定律被\textit{驳倒}的意义上，而是在于它没有被\textit{证实}。首先，任何我们有证明或驳斥的命题${\phi}$都已经确定，因此是可判定的。其次，我们可以根据需要提出证明或驳斥的广泛的命题类别。例如，两个整数是否相等是可判定的。第三点，也是最重要的一点，一直存在着这样的命题${\phi}$，其尚未解决：可能证明${\phi}$为真，或者可能证明${\phi}$是假。由于这些原因，构造性逻辑并\textit{没有反驳}可判定性命题：对于任何命题${\phi}$，${\lnot\lnot}$(${\phi \land \lnot\phi}$)都为真。使用本章给出的规则来证明它。


\textbf{12.2}.命题${\lnot\lnot\phi}$不强于${\phi}$：证明${\phi\supset\lnot\lnot\phi}$为真。 \textit{双否律}（DNE）规定对于每个命题${\phi}$都有（${\lnot\lnot\phi}$）${\supset\phi}$真。 本题以习题12.1为基础，因为证明DNE需要LEM，试证明该论断。


\textbf{12.3}.由前文所给构造逻辑的规则定义关系${\phi\leq\psi}$表示$\phi\;\mathsf{true}  \vdash \psi\; \mathsf{true}$。关于这种关系，有以下事实：

（a）这是一个预序，也就是说它具有反射性和传递性。

（b）${\phi\land\psi}$是${\phi}$和${\psi}$\textit{交集}，或\textit{最大下界}，${\top}$是\textit{极大}或者\textit{最大}元素。%代数结构

（c）${\phi\lor\psi}$是${\phi}$和${\psi}$\textit{并集}，或\textit{最小上界}，${\bot}$是\textit{极小}或者\textit{最小}元素。

（d）${\phi\supset\psi}$是\textit{指数集}，或\textit{伪补}，因此有最大的${\rho}$使得${\phi \land \lnot\rho\leq\bot}$（指数集${\phi\supset\psi}$有时也写成 ${\psi^\phi}$）。

总之这些事实表明了构造命题逻辑中的蕴含形成了\textit{海廷代数}。证明在这个意义上，普遍的海廷代数（即上述结构的序）是\textit{分配的}

$$
\begin{array}{c}
    \phi\land(\psi_1\lor\psi_2)   \equiv (\phi\land\psi_1)\lor(\phi\land\psi_2)  \\
    \phi\lor(\psi_1\land\psi_2)   \equiv (\phi\lor\psi_1)\land(\phi\lor\psi_2)
\end{array}
$$

其中${\phi\equiv\psi}$表示${\phi\leq\psi}$且${\psi\leq\phi}$。


\textbf{12.4}.对于任何的海廷代数，我们有${\phi \land \lnot\phi\leq\bot}$，也就是说否定与否命题是不一致的。但是${\lnot\phi}$不一定是${\phi}$的\textit{补}，因为${\phi \lor \lnot\phi\leq\top}$。布尔代数是一个海廷代数，其中否定总是否命题的补：对于每个${\phi}$，${\lnot\phi\leq\top \lor \phi}$。二元布尔代数交集，并集和指数集的验证由经典的真值表给定（定义当（${\lnot\phi}$）${\land\psi}$是布尔代数时${\phi\supset\psi}$）。结论是：可以将LEM与构造逻辑连接，也就是说经典逻辑是一个我们假设每一个命题都是可确定的构造逻辑的特例。每一个符合海廷代数的布尔代数都明显是分配的。证明每一个布尔代数也满足\textit{摩根对偶定律}：

$$
\begin{array}{c}
    \lnot(\phi\lor\psi)   \equiv \lnot\phi\land\lnot\psi   \\
    \lnot(\phi\land\psi)   \equiv \lnot\phi\lor\lnot\psi
\end{array}
$$

其中第一个在任何海廷代数中都是有效的;第二个仅于布尔代数有效。

