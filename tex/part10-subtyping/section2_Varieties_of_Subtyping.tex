\section{各种子类型的定型}\label{section:structural_subtyping_Varieties_of_Subtyping}
在本小节我们将对不同形式的子类型的定型进行一些非正规化的探究。
以下讨论的背景为第二十章中介绍的FPC语言的扩展。
% 此处的章节号应为引用
\ctexset{paragraph/runin=false}
% 设定paragraph标题后自动换行
\paragraph{数值类型}
%段落标题是不是加粗一下比较好？仅仅用黑体并不显眼啊
我们以对于许多编程语言中常见的数值类型的非正规化讨论作为开始。
我们的数学运算经验启示了一些数值类型中的子类型关系。
比如，假设一个编程语言有类型int，rat和real，分别用来代表整数，有理数和实数，
我们很容易做出如下的子类型关系假设：
$$\mathrm{int<:rat<:real}$$
这个假设类似于集合的包含关系：
$$\mathbb{Z\subseteq Q\subseteq R}$$

然而，这些子类型关系是合理的吗？这取决于我们如何表达和解释这些类型。
即便是在数学概念中，上述包含关系也并不总为真————或者说只是大体上为真。
比如说，有理数集合也可以被当做是由有序整数对$(m,n)$，$n\neq0\texttt{且}gcd(m,n)=1$组成，
表示$m/n$的比值。
整数集$\mathbb{Z}$可以被同态地嵌入到$\mathbb{Q}$，只要用$n/1$来区分不同的n即可。
%此处的isomorphically既可以被翻译为同态也可以翻译为同构，但是根据数学知识应该是同态，因为这个嵌入不是满射。
类似的，实数经常可以被表示为收敛的有理数列的极限，所以严格来讲有理数并不是实数的子集，
%吐槽一句，当读者没学过高数么
并非每个有理数都可以以某种正规的表示形式嵌入到实数集中。

如果是为了一般的数学目的，忽略像是$\mathbb{Z}$和它在$\mathbb{Q}$内的嵌入之间的细小区别是完全合理的。
这是因为对于有理数的运算仅限于整数在其中的嵌入：
如果我们将两个整数当做有理数的正规表示来相加，
那么结果是一个与它们的和相关的有理数。
对于其他运算，情况是类似的，只要我们在定义它们的时候小心谨慎，
以确保这些运算不会出错。
但如果是为了程序计算目的，我们必须考虑算法效率和机器的数值表达的有限性。
比如，我们常说的“实数”在编程语言中其实是浮点数，而浮点数是有理数的有限子集。
并不是所有有理数都可以被准确地表示为浮点数。
而且，即便浮点算术的操作数有时能被准确表示为浮点数，
浮点算术也并不局限于有理数算术。

\paragraph{积类型}
积类型使得一种基于包容原则的子类型定型方式得以产生。
唯一的可以应用于积类型的值的除去形式是就是投影。
%Projection在本章暂时翻译为投影
%以下所有Dynamics,Statics均翻译为动态特性，静态特性，根据含义应该是指在动态、静态阶段符合的限制。
在对投影的动态特性的温和假设下，我们可以认定某个积类型是另一个积类型的子类型，
只要应用到父类的投影也可以合法地应用到子类型的值。

考虑在某个情景下，一个类型$\tau=\langle\tau_j\rangle_{j\in J}$为的值被需求。
有限积的静态特性（（10.3）中的规则）保证了我们对类型为$\tau$的值的唯一可能的操作
%（10.3）是别的章节的引用
就是通过它的第j项（$j\in J$）的投影来获取一个类型为$\tau_j$的值，而无需将它和一个变量绑定。
现在假设$e$的类型是$\tau{'}$，那么为了让投影$e\cdot j$合式，
应该有$\tau{'}$是一个有限积类型$\langle\tau_i{'}\rangle _{i\in I}$使得$j\in J$。
另外，为了让这个投影正好是类型$\tau _j$，只需要求$\tau _j {'}=\tau_j$。
由于$j\in J$中，$j$是任意的，我们最终得出如下的针对有限积类型的子类型定型规则：
\begin{equation}\label{equation:projection_suffice_rule}
	\frac{J \in I}{\prod_{i \in I}<:\prod_{j\in J}\tau_j}
\end{equation}
这项规则是得到所需子类型定型的充分条件，但并不是必要条件。
我们将会在小节\ref{section:structural_subtyping_Variance}讨论这项规则的更加自由的变式。
%liberal应该是值更弱条件，没想出来好的翻译。
规则\ref{equation:projection_suffice_rule}的一个合理解释是：无论$e$的真正形式是什么，
只要它有一个索引为$i\in I$的域，那么我们就能对$e\cdot i$求值。

\paragraph{和类型}
我们可以通过有限积类型中给定的参数的对偶参数推断出一条适用于有限和类型的子类型定型规则。
%没看懂这句话的英文，直接调整语序逐词翻译了
如果一个类型为$\sum_{j\in J}\tau_j$的值被需求，和的静态特性（（11.3）中的规则）
%11.3是别的章节的引用
确保了唯一可以对这个值进行的非平凡运算就是对$J$个索引对应的情况的分析。
%数学语境下的non-trivial是指非平凡，表示不是某些最基础的情况
如果我们提供一个类型为$\sum_{i\in I}\tau_i {'}$的值作为替代，只要$I \in J$并且
每个$\tau_i{'}$都等于$\tau_i$，就不会产生问题。
如果上述包含关系是真包含，有些和类型中的情况可能不会发生，但这并不会干扰安全性。
\begin{equation}
	\frac{I \in J}{\prod_{i \in I}<:\prod_{j\in J}\tau_j}
\end{equation}
注意和规则\ref{equation:projection_suffice_rule}相比，包含关系是颠倒的。

\paragraph{动态类型}
与在第23章中介绍的类型\texttt{dyn}相关的子类型的定型是一种常见的子类型定型形式。
%23章是别的章节的引用
类型\texttt{dyn}除了该类型的值所属的类以外没有提供任何信息。
有些人也许会认为策略性地压缩这些信息是动态定型的关键所在，
%dynamic typing 动态定型。如果觉得表意不清，可以修改为动态类型的定型。
因为这样就能让这些类型只在动态阶段可用。
但另一方面，引入\texttt{dyn}的子类型来指定值所属的类并不会带来很多麻烦，
这是因为在类型无法被静态地确定时，可以利用包容原理来“忘记”这些类。

在第23章内容的背景下，动态类型的子类的定型意味着引入两个新的类型，\texttt{dyn[num]}和\texttt{dyn[fun]}。
%23章为别的章节的引用
这两个类型由以下两条公理性的规则约束：
\begin{subequations}
    \begin{gather}
        \frac{}{\texttt{dyn[num]<:dyn}} \\
        \frac{}{\texttt{dyn[fun]<:dyn}}
    \end{gather}
\end{subequations}
当然，在拥有更多动态值的类的编程语言中，有人也许会想为每个附加的类引入一个对应的\texttt{dyn}的子类型。
为了方便标记，类型\texttt{dyn}常常被说成是\texttt{对象}，而它的类依赖的子类型\texttt{dyn[num]}和\texttt{dyn[fun]}常被分别写成\texttt{num}和\texttt{fun}。
%class-specific 类特定，类依赖，类规范，有多种翻译，不知道该如何取舍，都不是很贴切
但是这样做可能会引起对于\texttt{类}和\texttt{类型}的概念混淆，这会在第22和23章中详细介绍。
%22 23 别的章节的引用。
%本段接下来所有的class直接翻译为“类”，但是这种做法有可能引起读者难以分辨它和“类型”的区别，尽管文本并没有错
\texttt{dyn}的类依赖的子类型是通过重写引入类型\texttt{dyn}的值以标记的定型规则而产生的，这样做可以标识所创建的值的类：
\begin{subequations}
    \begin{gather}
        \frac{\Gamma \vdash e : \texttt{nat}}{\Gamma \vdash \texttt{new[num](e) : \texttt{dyn[num]}}} \\
        \frac{\Gamma \vdash e : \texttt{dyn} \rightharpoonup \texttt{dyn}}{\Gamma \vdash \texttt{new[fun](e) : \texttt{dyn[fun]}}}
    \end{gather}
\end{subequations}
这样一来，在这个重写的规则中，特定类的值刚出现时便具有类依赖的类型，因为在这些情况下，引入的值的类型是静态可见的。
在无法做出静态类型断言的情况下，利用包容原则将这些值的类型削弱到\texttt{dyn}。
比如说，当动态类型的条件估值的不同分支具有不同的类时，必须要将分支的类型削弱到\texttt{dyn}。

这样的子类型的定型化机制的优点在于我们可以表达更加精确的类型，
比如类型$\texttt{dyn[num]}\rightharpoonup\texttt{dyn[num]}$，它是一个将类型\texttt{dyn}的类\texttt{num}的值映射到另一个相同类的值上的函数。
和像是\texttt{dyn}$\rightharpoonup$\texttt{dyn}这样仅仅是能够区分出函数将动态类型映射到动态类型的定型相比，上述定型要精确得多。
即便弱不变量可以用原先的方法表达和执行，但是只有采用子类型的定型才能追踪计算过程中涉及到的值的类。
然而，子类型的定型机制并非足够强大，它并不能使得额外的特性区分能力掩盖采用这种方法的努力。
（一个更加强大的机制将在第25章给出）
%25章为别的章节的引用

